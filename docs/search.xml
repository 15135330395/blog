<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Fblog%2F2020%2F02%2F06%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%B8%B8%E7%94%A8SQL%2F</url>
    <content type="text"><![CDATA[mysql oracle 数字格式化 https://blog.csdn.net/pan_junbiao/article/details/86519389https://blog.csdn.net/u013456370/article/details/74923338 Oracle 计算两个日期间隔的天数、月数和年数https://blog.csdn.net/u013991521/article/details/79293846 oracle截取日期、时间 https://blog.csdn.net/haiross/article/details/12837033trunc(sysdate,’y’)统计周期（本年1月1日 到 本年12月31日）select trunc(sysdate,’y’),last_day(add_months(trunc(SYSDATE,’y’),11)) from dual增加、减少月份 https://blog.csdn.net/baidu_36695217/article/details/79798531add_months(日期,正负数)]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS介绍]]></title>
    <url>%2Fblog%2F2019%2F09%2F27%2F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%A1%86%E6%9E%B6%2F%E5%89%8D%E7%AB%AF%2FJS%E5%8F%8AJQuery%2FJS%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[JS组成 core 文档对象 浏览器对象 配置位置页面加载顺序从上到下 位于body最后 打开页面先加载html和css 提升用户体验 公共JS部分封装在一个js文件中易维护、可缓存 特有方法字符串： 数字： 数组： 和Java方法不同： null、””、undefined区别]]></content>
      <categories>
        <category>JS及Jquery</category>
      </categories>
      <tags>
        <tag>JS介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis的使用]]></title>
    <url>%2Fblog%2F2019%2F09%2F25%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%2FRedis%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[NOSQLNOSQL和关系型数据库比较优点 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式：nosql的存储格式是key，value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库十几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 非关系型数据库的优势： 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势： 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 总结关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 主流的NOSQL产品 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 应用场景网上 缓存（数据查询、短链接、新闻内容、商品内容等）（最多） 聊天室的在线好友列表 任务队列（秒杀、抢购、12306等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒） 分布式集群框架中的session分离 推测 当前登录人员信息（统计所有登陆人员）————&gt; 所有的用户及其权限 和组织机构 数据字典 菜单 union表（相当于统计计算 但要求可靠性） 当前流程环节 通知 session 发送邮件 短信的验证码及其发送间隔期限 有期限的东西 实时聊天 所有的统计登录访问次数 简单的消息队列 放到缓存中的东西 不能用redis： 数据量太大、数据访问频率非常低的业务都不适合使用Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。 存储结构及指令使用Redis支持类型1．String（字符串）命令： 增：set 键 字符串值查询：GET 键返回key对应字符串值的指定字符：GETRANGE 键 开始 结束（包含）设置并返回旧值：GETSET 键 新值获取/设置多个key：MGET 键1 键2 …./MSET 键1 值1 键2 值2 ….当value为整数数据时，可以设为自增：INCR 键 / INCRBY 键 步长 自减：DECR 键 / DECR 键 步长向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度：APPEND 键 值获得字符串长度 键不存在则返回0：STRLEN 键 2．Hash（哈希，key-value，适合存储对象 key是对象 value是属性 字段值只能是字符串类型）命令： 增：hmset 键 字段1 字段值1 字段2 字段值2 …. HSET 键 字段 字段值（只能设置一个字段值 不区分插入和更新操作 插入返回1 更新返回0）删：HDEL 键 字段1 字段2 ….查：HGET 键 字段 HMGET 键 字段1 字段2 ….（获取多个字段值） HGETALL 键（获取所有的字段和字段值）判断字段是否存在：HEXISTS 键 字段只获取字段名或字段值：HKEYS 键 / HVALS 键获取字段数量：HLEN 键 3．List（列表 本质是双向链表）命令： 向列表左/右增加元素：lpush/RPUSH 键 值1 值2 ….移出并获取列表的第一个/最后一个元素，等待时间设置为秒，阻塞：BLPOP/BRPOP 键 时间求长度：LLEN 键移出并获取列表的第一个/最后一个元素：LPOP/RPOP 键查看列表：LRANGE 键 开始 结束 4．Set（集合，无序不重复）命令： 增：sadd 键 值1 值2 ….获取数量：SCARD 键获得所有元素：SMEMBERS 键删除：SREM 键 值1 值2 ….判断元素是否在集合中：SISMEMBER 键 值1差集/交集/并集：SDIFF/SINTER/SUNION 键1 键2返回并移除指定set中的随机某个元素：SPOP 键 5．zset(sorted set：有序值不重复 序/分数可以相同)命令： 增：zadd 键 序1 值 序2 值2 ….获得有序集合数量：ZCARD 键获得有序集合指定范围的从小到大的值：ZRANGE 键 开始 结束（包含）获得有序集合指定范围的从大到小的值：ZREVRANGE 键 开始 结束（包含）WITHSCORES（获得分数）获取元素的分数：ZSCORE 键 值删除：ZREM 键 值1 值2 …. 通用：命令： 删除键：DEL 键键是否存在：EXISTS 键查看所有满足条件的key：KEYS 键开头*（模板）重命名：RENAME 旧键 新键显示指定key的数据类型：type key设置key的有效期，单位为seconds：EXPIRE 键 时间删除key的有效期，变为永久有效：PERSIST 键返回key的剩余有效时间，pttl返回毫秒，ttl返回秒：TTL/PTTL 键 事务 开启事务：MULTI触发事务，提交：EXEC取消事务，清除：DISCARD当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的状态：watch 键1 键2 ….（可以实现乐观锁）清除所有先前为一个事务监控的键：unwatch Redis不支持事务回滚1.大多数事务失败是因为语法错误或者类型错误，这两种错误，在开发阶段都是可以预见的（旧版本 如果出现异常 则忽略）2.为了性能方面就忽略了事务回滚 从 Redis 2.6.5 开始, 在命令排队期间发生错误，Redis会拒绝执行 EXEC，并返回一个错误，然后自动放弃这个事务。在 Redis 2.6.5 之前，EXEC调用后，会执行排队成功的命令，忽略失败的命令。 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。 RedisUtils.java12 Redis可视化连接工具花钱的 但比较火redis desktop manager（RDM） 不花钱的AnotherRedisDesktopManager （比较简洁好看）RedisClient （丑了点）Web Redis Manager（管理页面是layui） Jedis普通环境Jedis 包：jedis-2.9.0.jar + 数据库连接池包：commons-pool2 12345678// 1.设置IP地址和端口Jedis jedis = new Jedis("localhost", 6379);// 2.设置数据jedis.set("key1", "value1");// 3.获得数据String value = jedis.get("key1");// 4.释放资源jedis.close(); 可以封装成Utils工具类 1private Jedis jedis = new Jedis("localhost", 6379); 连接池连接 123456789101112131415161718192021222324252627// 1.获得连接池配置对象，设置配置项JedisPoolConfig config = new JedisPoolConfig();// 最大连接数和最大空闲连接数config.setMaxTotal(30);config.setMaxIdle(10);// 2.创建连接池对象JedisPool jedisPool = new JedisPool(config,"127.0.0.1", 6379);// 3.从连接池中获得连接Jedis jedis = null;try&#123; jedis = jedisPool.getResource(); // 4.设置数据 jedis.set("key1", "value1"); // 5.获得数据 String value = jedis.get("key1");&#125; catch (Exception e)&#123; e.printStatckTrace();&#125; finally &#123; // 6.关闭连接 if(jedis != null)&#123; jedis.close(); &#125; // 7.关闭连接池 if(jedisPool != null)&#123; jedisPool.close(); &#125;&#125; spring整合（本身线程不安全 需要数据库连接池的支持）Jedis+pool spring环境的高级封装RedisTemplate配置redis.properties：#访问地址redis.host=127.0.0.1#访问端口redis.port=6379#注意，如果没有password，此处不设置值，但这一项要保留redis.password=#最大空闲数，数据库连接的最大空闲时间。超过空闲时间，数据库连接将被标记为不可用，然后被释放。设为0表示无限制。redis.maxIdle=300#连接池的最大数据库连接数。设为0表示无限制redis.maxTotal=600#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。redis.maxWait=1000#在borrow一个jedis实例时，是否提前进行alidate操作；如果为true，则得到的jedis实例均是可用的；redis.testOnBorrow=true spring-redis.xml： &lt;context:property-placeholder location=”classpath:redis.properties” file-encoding=”utf-8” ignore-unresolvable=”true”/&gt; 在applactionContext.xml引入spring-redis.xml springboot环境整合可以直接注入RedisTemplate + reids配置类 123456789101112131415&lt;!-- redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; application.yml：spring: redis: database: 0 host: localhost port: 6379 password: timeout: 0 jedis: pool: max-active: 8 max-wait: 20000 max-idle: 20 RedisConfiguration.java：序列化的配置// StringRedisSerializer\JdkSerializationRedisSerializer进行序列化的，springboot是通过Jackson2JsonRedisSerializer进行序列化的]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle的常用SQL]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2Foracle%2Foracle%E7%9A%84%E5%B8%B8%E7%94%A8SQL%2F</url>
    <content type="text"><![CDATA[oracle分页SELECT * FROM ( SELECT rownum rn ,t1.* FROM OA_QY_KQGL_XJTJB_SUB t1 , ORG_ORGANIZATION t2 WHERE rownum &lt;= (1+1) * 15 and t1.bmname=t2.orgname and t1.mid=461 order by t2.sortno ) WHERE rn &gt; 1 * 15oracle查询 数据断层主键SELECT ROWNUM FROM ALL_OBJECTS WHERE ROWNUM &lt; = (SELECT MAX(t.wfhisid) FROM ERP_WORKFLOW_HIS t) MINUS SELECT t.wfhisid FROM ERP_WORKFLOW_HIS toracle查询某个列名在哪些表中select column_name,table_name from user_tab_columns where lower(column_name)= lower(&apos;列名&apos;)Oracle创建序列缓存CREATE SEQUENCE --序列名称 INCREMENT BY 步长 START WITH 起始值 MAXVALUE 最大值 /NOMAXvalue --无最大值 MINVALUE 最小值 CYCLE/NOCYCLE --是否循环 最大值用完 是否从start with开始 否则从MINVALUE开始（NOCYCLE和NOMAXvalue一起用） CACHE 缓存大小 --会造成跳号 Order/NOORDER; --排不排序 一般不排序 sequence number是timestamp才排序Oracle使用序列缓存CurrVal：返回 sequence的当前值 NextVal：增加sequence的值，然后返回 增加后sequence值 SELECT 序列名称.CurrVal FROM 表 insert into 表名(id,name)values(序列名称.Nextval,&apos;sequence 插入测试&apos;); 注：必须先NextVal才能CurrVal ； 在同一个语句里面使用多个NEXTV，其值不一样（++i）创建触发器做自增主键create or replace trigger 触发器名称 before insert on 表 --before:执行DML等操作之前触发 for each row --行级触发器 begin select 序列名.nextval into :new.id from dual; end;常用SQLto_char(LOANDATE,&apos;yyyy-MM-dd&apos;) LOANDATE, ( SELECT e.dictname FROM eos_dict_entry e WHERE e.dicttypeid = &apos;IPM_ZHBG_SQDLX&apos; AND e.dictid = a.APPLICATIONTYPE ) APPLICATIONTYPE SELECT LOWER(&apos;IPM_CONTRACT_SALE_KXXX&apos;) FROM dual SELECT &apos;$F{&apos;||UPPER(&apos;ms&apos;)||&apos;}&apos; FROM dual查询重复数据select * from 重复记录字段 in ( select 重复记录字段 form 数据表 group by 重复记录字段 having count(重复记录字段)&gt;1)Oracle查询操作日志SELECT t.SQL_TEXT, t.FIRST_LOAD_TIME FROM v$sqlarea t WHERE t.FIRST_LOAD_TIME LIKE &apos;2019-07-18%&apos; AND lower( t.SQL_TEXT ) LIKE &apos;%prp_car_%&apos; AND lower( t.SQL_TEXT ) NOT LIKE &apos;%select%&apos; ORDER BY t.FIRST_LOAD_TIME DESCoracle闪回alter table 表名 enable row movement --恢复表数据 flashback table 表名 to timestamp to_timestamp(删除时间点&apos;,&apos;yyyy-mm-dd hh24:mi:ss&apos;) --关闭行移动功能 alter table 表名 disable row movement##oracle查询最近删除的数据 SELECT * FROM 表 AS OF TIMESTAMP sysdate-1/24 where 条件 整理角色用户权限with tab1 as ( SELECT a.ROLE_ID 角色id, a.ROLE_NAME 角色名, WM_CONCAT(c.empname) 当前用户 FROM CAP_ROLE a LEFT JOIN cap_partyauth b ON a.ROLE_ID = b.ROLE_ID , ORG_EMPLOYEE c WHERE b.PARTY_ID = to_char(c.empid) group by a.ROLE_ID, a.ROLE_NAME ORDER BY a.ROLE_ID ), tab2 as( select PARTY_ID,wmsys.wm_concat(funcname) 菜单名 from (select a.PARTY_ID, b.funcname, sum(lengthb(b.funcname||&apos;,&apos;)) over(partition by PARTY_ID ) descr_length from CAP_RESAUTH a LEFT JOIN APP_FUNCTION b ON a.RES_ID = b.funccode ) where descr_length &lt; 4000 group by PARTY_ID) select tab1.角色ID,tab1.角色名,tab1.当前用户,tab2.菜单名 from tab1 LEFT JOIN tab2 on tab1.角色id=tab2.PARTY_ID列说明无效 需要查看oracle关键字select * from v$reserved_words;]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入门操作]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2Foracle%2F%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.cmd下 sqlplus 进入oracleconnect as sysdba 登陆（需要设置登陆验证 安装目录\product\NETWORK\ADMINNONE\sqlnet.ora 里面NONE状态无效 但可以登陆远程服务器） 或 sqlplus / as sysdba alter user scott account unlock conn scott/tiger2.创建表空间create tablespace XNYMPMS logging datafile &apos;D:\oracle\data\XNYMPMS.dbf&apos; size 50m autoextend on next 50m maxsize 20480m extent management local;（3.删除用户以及其数据）drop user qyepc cascade;4.创建用户create user XNYMPMS identified by XNYMPMS default tablespace XNYMPMS; create user qyepc identified by qyepc;5.赋予权限grant connect,resource,dba to XNYMPMS; 6.cmd下导入oracle的dmp文件imp qyepc/qyepc@localhost/orcl file=&quot;qyepc20190730.DMP&quot; full=y;修改dbf文件路径sys as sysdba关闭数据库 shutdown immediate;以mount方式启动数据库 startup mount;修改dbf文件路径 alter database rename file &apos;D:\oracletableplace\XNYMPMS.DBF&apos; to &apos;D:\oracle\oradata\orcl\XNYMPMS.dbf&apos;;打开数据库 alter database open;oracle默认排序Oracle查询以堆读取数据 结果无序 rowid 可能会有排序的假象 dual伪表 只有一行一列DUMMY 数据为VERCHAR2(1) ‘X’ 为了让select语句完整 符合语法规则 select 1+2 from dual修改密码忘记密码windows1.忘记system 和sys密码 但用操作系统验证sqlplus / as sysdba能够登陆 登陆后直接修改密码 解锁账户2.忘记system 和sys密码（只忘记一个 用另一个改密码）且操作系统为家庭版（无本地策略组）、设为NTS 操作系统验证仍然无权限管理员cmd下 orapwd file=安装路径\database\PWDorcl.ora password=orcl force=y nosysdba=n修改密码 alter user system identified by orcl解锁账户 alter user system account unlocklinux如果忘记密码 可以登陆oracle用户（windows本地策略组也有） 进行操作系统验证也可以重置密码 orapwd file=安装路径\dbs\ORAPWorcl password=orcl force=y nosysdba=n]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>入门操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml文件转义]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%A1%86%E6%9E%B6%2F%E5%90%8E%E5%8F%B0%2FSSM%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%2FMyBatis%2Fxml%E6%96%87%E4%BB%B6%E8%BD%AC%E4%B9%89%2F</url>
    <content type="text"><![CDATA[xml写 大于＞ 小于＜ 1.特殊标签 如： select * from table a where a.field 20 &gt;= #{field} select * from table a where &lt;if 条件&gt; a.field #{field} 2.转义字符 ＞：&gt; ＜：&lt; 在XML中，需要转义的字符有： (1)&amp; &amp; (2)＞ &lt; (3)＞ &gt; (4)” &quot; (5)＇ &apos; 但是严格来说，在XML中只有”&lt;”和”&amp;”是非法的，其它三个都是可以合法存在的，但是，把它们都进行转义是一个好的习惯。 不管怎么样，转义前的字符也好，转义后的字符也好，都会被xml解析器解析，为了方便起见，使用来包含不被xml解析器解析的内容。但要注意的是： (1) 此部分不能再包含”]]&gt;”； (2) 不允许嵌套使用； (3)”]]&gt;”这部分不能包含空格或者换行。 最后，说说和xml转移字符的关系，它们两个看起来是不是感觉功能重复了？ 是的，它们的功能就是一样的，只是应用场景和需求有些不同： (1)不能适用所有情况，转义字符可以； (2) 对于短字符串写起来啰嗦，对于长字符串转义字符写起来可读性差； (3) 表示xml解析器忽略解析，所以更快。 HTML特殊转义字符对照表 HTML字符实体转换]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>xml文件转义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义编码]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%A1%86%E6%9E%B6%2F%E5%89%8D%E7%AB%AF%2FJS%E5%8F%8AJQuery%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233//根据表名和编码字段获取最大编码function createOAMaxCode(module,tablename,codefiled)&#123; var yearAndMonth=nui.formatDate(new Date(),"yyyyMM"); var maxCode = ""; var sqlStr =" select max(substr("+codefiled+",-3)) as maxCode from "+tablename+" where "+codefiled+" like '"+module+"-"+new Date().getFullYear()+"%'"; console.log(sqlStr); var ret = ERP.runSql(sqlStr, "select", false); console.log(ret); var retNum = parseInt(ret.dataObject[0].MAXCODE); console.log(retNum); var re = /^[0-9]+.?[0-9]*/;//判断字符串是否为数字//判断正整数/[1−9]+[0−9]∗]∗/ if(ret.result == 'success' &amp;&amp; isEmpty(ret.dataObject[0].MAXCODE))&#123;//如果是新的一年则编码从1计数 maxCode="001"; &#125;else if( !re.test(ret.dataObject[0].MAXCODE))&#123;//查询出错 maxCode="编码生成错误，请手动输入.."; &#125; else&#123; maxCode = PrefixInteger(retNum+1,3);//最大编码数值 &#125; var modeCode = module+"-"+yearAndMonth+"-"+maxCode; return modeCode;&#125;//补0function PrefixInteger(num, length) &#123; return (Array(length).join('0') + num).slice(-length);&#125;//判断字符是否为空function isEmpty(obj)&#123; if(typeof obj == "undefined" || obj == null || obj == "")&#123; return true; &#125;else&#123; return false; &#125;&#125;]]></content>
      <categories>
        <category>JS及Jquery</category>
      </categories>
      <tags>
        <tag>自定义编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL优化]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[MySQL百万级数据分页查询及优化https://www.cnblogs.com/dreamroute/p/11118581.html 有关mysql优化的准则https://erik.xyz/2016/03/01/you-guan-mysql-you-hua-de-zhun-ze/]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>SQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完整的url地址]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2Ftomcat%2F%E5%AE%8C%E6%95%B4%E7%9A%84url%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[在编写接口代码时，尽量使用request中获取的完整地址确保拓展性 如https协议 域名 修改端口并注释上是请求哪的服务器如果是测试数据，记得注明，测试完注释 项目名（webapp文件夹名）String path = request.getContextPath();URL地址String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;; &lt;a href=&quot;&lt;%=basePath%&gt;&quot; /&gt;]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github pages博客]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%A1%86%E6%9E%B6%2F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%2FGit%E5%8F%8AGithub%2Fgithub%20pages%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[github搭建博客（hexo）1.安装gitgit –version 2.安装node.js安装版（记得勾选add path） 免安装版（配置环境变量）注意：npm是Node.js自带的模块包管理工具，跟node.exe位于同一文件夹。Hexo项目也是提供了命令行工具hexo.cmd。这个项目被所有的实例共享，Hexo一般应全局安装。它的hexo.cmd所在文件夹应被放入系统path变量中。node -vnpm -v 3.安装hexo（似乎安装到nodejs目录下了） npm install hexo-cli -ghexo -v 该命令会显示hexo的版本及依赖的包。 4.创建blog文件夹5.cmd命令 进入blog文件夹 初始化hexohexo init生成文件夹和文件node_modules 依赖包public 存放的是生成的页面scaffolds 命令生成文章等的模板source 用命令创建的各种文章themes 主题.gitignore 不上传文件_config.yml 整个博客的配置文件db.json source解析所得到的package.json 项目所需模块项目的配置信息 6.安装或下载NexT主题插件git clone https://github.com/iissnan/hexo-theme-next themes/next或者，直接从发布页https://github.com/iissnan/hexo-theme-next/releases下载源指定版本源代码。下载之后，解压缩主题主题文件，并把它放到themes 7.修改站点配置文件#原来的值是landscapetheme: next 8.启动hexo的服务器hexo server 9.访问 http://localhost:400010.下载hexo插件（可能还需要升级hexo部分插件）字数统计 npm install hexo-wordcount –savegit部署 npm install hexo-deployer-git –save本地搜索 npm install hexo-generator-searchdb –save2d特效 npm install hexo-helper-live2d –save本地图片插件 npm install hexo-asset-image –save 11.修改主题配置文件themes/主题/_config.yml根据集成的插件 选择性的开启如：评论区 访问统计等 常用操作生成 aboutme 页面 hexo new page about生成标签页面 hexo new page tags 在tags中的index.md中新增一行 type: “tags”生成分类页面 hexo new page categories 在categories中的index.md中新增一行 type: “categories”以上三个页面如果有评论 需要关掉评论 index.md加上comments: false 写文章 hexo new 标题/文件名写草稿 hexo new draft 标题/文件名预览草稿 hexo server –draft发表草稿 hexo publish 草稿标题/文件名 hexo g 生成静态文件hexo s 启动服务器hexo clean 清除缓存和已经生成的public静态文件 源文件存放在source中静态文件存放在public中（都可以改） 2d特效（https://www.simon96.online/2018/10/12/hexo-tutorial/）将以下代码添加到主题配置文件_config.ymllive2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-&lt;你喜欢的模型名字&gt; #miku z16 wanko display: position: right width: 150 height: 300 mobile: show: true在站点目录下建文件夹live2d_models再在live2d_models下建文件夹&lt;你喜欢的模型名字&gt;再在&lt;你喜欢的模型名字&gt;下建json文件：&lt;你喜欢的模型名字&gt;.model.json安装模型。在命令行（即Git Bash）运行以下命令即可：npm install –save live2d-widget-model-&lt;你喜欢的模型名字&gt;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s https://blog.csdn.net/u012195214/article/details/79204088 本地文件上传1.把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true2.安装插件3.在md文件旁生成同名文件夹（如果是hexo n “xxxx”来生成md博文 可以自动创建文件夹）4.图片放在文件夹里，在md文件里面插入图片 1![你想输入的替代文字](xxxx/图片名.jpg) 12.推送到github上创建repo 名为 username.github.io（username是github名称）配置github账户信息部署 根据需求 修改域名第一步购买域名：随便在哪个网站买一个就好了，可以在阿里云购买第二步添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加购买的域名第三步再次部署一下 资料https://hexo.io/themes/ hexo的主题地址https://hexo.io/zh-cn/docs/ hexo的使用文档 github搭建博客（VuePress）https://segmentfault.com/a/1190000015237352?utm_source=tag-newest 1.安装npm install -g vuepress 2.创建项目目录并初始化mkdir 项目名cd 项目名npm init -y 3.创建项目文档根目录mkdir docs 4.在docs目录中，创建.vuepress目录mkdir .vuepress 5.在docs中创建config.js6.创建public文件夹cd ../.vuepressmkdir public 项目结构：project├─── docs│ ├── README.md│ └── .vuepress│ ├── public│ └── config.js└── package.json config.js的基本配置module.exports = { title: ‘标题’, description: ‘描述’, head: [ [‘link’, { rel: ‘icon’, href: ‘/img/logo.ico’ }], [‘link’, { rel: ‘manifest’, href: ‘/manifest.json’ }], ]} 常用操作.生成静态文件vuepress build docs.本地运行vuepress dev docs访问http://localhost:8080]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github pages</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql8.0的url]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%2Fmysql8.0%E7%9A%84url%2F</url>
    <content type="text"><![CDATA[jdbc:mysql://IP:3306/库?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql8.0的url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql常用SQL]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%2Fmysql%E5%B8%B8%E7%94%A8SQL%2F</url>
    <content type="text"><![CDATA[mysql分页mysql查询列名]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql8.0的url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSL证书和https协议]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2Ftomcat%2FSSL%E8%AF%81%E4%B9%A6%E5%92%8Chttps%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[配置https协议​ 1.单向认证，就是传输的数据加密过了，但是不会校验客户端的来源​ 2.双向认证，要求客户端浏览器没有导入客户端证书，是访问不了web系统的，找不到地址，双向认证的安全级别较高 方法1.获得证书购买或自制（购买 阿里云免费申请1年https://www.aliyun.com/product/cas JDK自带的keytool自己生成） JDK自带的keytool自己生成步骤： 1.打开 JDK 自带的 keytool 目录 2.按住 Shift 键，同时右键点击空白处。 3.cmd窗口。输入keytool -genkeypair -alias “别名” -keyalg “RSA” -keystore “D:\生成地址.keystore” -validity 36500（有效期100年 默认90天） 4.输入两次密钥、名字与姓氏:192.168.0.110或域名（以后访问的域名或IP地址，非常重要，证书和域名或IP绑定）、 剩下随便填 2.应用证书到Tomcat（SSL证书文件后缀可能是.keystore .pfx .jks 不影响配置 可以互相转换）打开 Tomcat 配置文件 conf\server.xml取消注释，并添加两个属性 keystoreFile，keystorePass。 8.5之前 8.5之后 (阿里云申请的配置keystoreFile是PFX证书文件地址，keystorePass是阿里云的订单号，keystoreType直接写PKCS12) 3.测试启动tomcat并访问https://127.0.0.1:8443如果把所有的8443改为443 则访问时 不需要加端口 即https://127.0.0.1 4.使用自己生成的证书会遇到几个问题浏览器会对 HTTPS 使用危险标识。(我们开启 HTTPS 本意是为了更安全，增加用户信心。但是浏览器使用危险标识会适得其反，吓跑用户。)浏览器默认不会加载非HTTPS域名下的javascript移动设备显示页面空白(手机浏览器打开页面，也会像桌面浏览器一样弹出是否加载不受信任的页面，在微信中打开则会一片空白)可以将证书的详细信息页面导出（复制到文件），导入浏览器（Internet选项——内容——证书——受信任的根证书颁发机构——导入证书） 5.配置强制访问https（按需 没用过）tomcat /conf/web.xml 中的 后面加上以下内容 123456789101112131415&lt;login-config&gt; &lt;!-- Authorization setting for SSL --&gt; &lt;auth-method&gt;CLIENT-CERT&lt;/auth-method&gt; &lt;realm-name&gt;Client Cert Users-only Area&lt;/realm-name&gt; &lt;/login-config&gt; &lt;security-constraint&gt; &lt;!-- Authorization setting for SSL --&gt; &lt;web-resource-collection &gt; &lt;web-resource-name &gt;SSL&lt;/web-resource-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/web-resource-collection&gt; &lt;user-data-constraint&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; &lt;/user-data-constraint&gt; &lt;/security-constraint&gt; 完成以上步骤后，在浏览器中输入http的访问地址也会自动转换为https了 换成https协议以后可能出现的问题换https之前 系统正常，换了以后 不兼容IE9以下因为浏览器的兼容模式是根据域名判断的 之前用的IP地址访问，不会用到兼容模式，用域名访问就会用到兼容模式 当时情况1.必须使用IE浏览器2.必须兼容IE73.必须使用特定域名访问（兼容性通过主域名判断 即 powerchina.cn） 解决办法强制突破IE浏览器兼容性视图几种形式： &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; &gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=11&quot; &gt;或 &lt;% response.addHeader(&quot;X-UA-Compatible&quot;, &quot;edge&quot;);// (似乎不起作用) %&gt;或nginx配置文件 location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:8080; client_max_body_size 1000m; add_header &quot;X-UA-Compatible&quot; &quot;IE=11&quot;; }https协议下部分浏览器保存报错https携带参数限制 当时状况1.http协议正常2.https协议下谷歌浏览器数据保存时 弹窗信息是错误页面 但保存正常IE浏览器数据保存时 ajax返回信息是错误页面tomcat控制台报错信息是 org.apache.axis2.transport.http.CommonsHTTPTransport org.apache.axis2.AxisFault 但没有用到关于web service 原因传输数据量过大 50到100条数据 但主要是大段的文字（Post提交本身对于参数的长度没有限制，HTTP协议也没有限制）tomcat有限制缺省的情况下是maxPostSize=”2097152” 2M 单位是Byte 解决办法1.保存时 去掉没用的数据2.修改server.xml文件maxPostSize=”-1” 12345&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot; clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; maxPostSize=&quot;-1&quot; keystoreFile=&quot;conf/文件.jks&quot; keystorePass=&quot;密码&quot; /&gt; 关于Tomcat的maxPostSize属性的配置需要注意的问题 除了服务器对url长度有限制 浏览器也有所有参数都拼接到访问路径上，而且都是转码后的字符，参数非常多内容又非常长,从而导致了在某些浏览器上访问时报500，原因是url的长度超出了浏览器的限制，以下是各个浏览器的url长度限制 Safari 最大长度限制为80000字节 Opera 最大长度限制为190000字节 Chrome 最大长度限制为8182字节 IE 最大长度限制为2048字节 Firefox 最大长度限制为65536字节 解决办法javascript动态创建Form表单和表单项，然后提交表单请求，最后删除表单js动态创建Form表单并提交 SSO单点登录出现文件当时状况单独访问https的项目正常，从门户系统跳转出现问题 解决办法查看报错信息1.如果是单点登录的验证出现问题 则查看单点登录的配置文件 sso-conf（本地可能没有 在服务器上）2.单点系统中用户名修改 但本系统没改 导致用户名不匹配 则重新配置组织结构里的用户名 tomcat7漏洞过多解决办法升级tomcat 换成97到8、9 配置文件需要加上URIEncoding=”ISO-8859-1”7的request请求默认是ISO-8859-18、9的request请求默认是UTF-8 升级tomcat后 部分地址不可用 错误400使用Tomcat传url地址中包含大括号{}的特殊字符无法识别问题多种解决方法tomcat升级到8之后URL中带的特殊字符如:^|报400问题解决方案url中不允许有 |，{，}等特殊字符仅在以下版本可用 8.5.x for 8.5.12 onwards 8.0.x for 8.0.42 onwards 7.0.x for 7.0.76 onwards 否则需要转义 var url = encodeURI(&quot;http://localhost:8080/default/aaa.jsp?data={name:1}&quot;);或 encodeURIComponent()]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>https遇到的问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指定端口、修改jdk]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2Ftomcat%2F%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3%E3%80%81%E4%BF%AE%E6%94%B9jdk%2F</url>
    <content type="text"></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat指定端口、修改jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导入导出]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2Foracle%2F%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[导出导出整个数据库方法一：（可以导出空表 建议使用） sqlplus中 create or replace directory file_path as &apos;D:\oracle\data&apos;; cmd下（version防止数据库版本不同 服务器版、标准版） expdp fjznsd/fjznsd@localhost/orcl directory=file_path dumpfile=fjzn.dmp logfile=fjzn.log schemas=FJZNSD version=10.2.0方法二： exp qyepc/qyepc@192.168.2.83:1521/orcl file=E:\qyepc.DMP owner=qyepc（11G默认不导出空表）方法三： navicat 数据传输 同步表结构、表数据方法四： 导出表结构和数据的sql（非常慢 并且不能导出大数据字段BLOB和CLOB） Oracle 11G在用exp导出时，空表不能导出解决：1、先查询一下当前用户下的所有空表 select table_name from user_tables where NUM_ROWS=0;2、用以下这句查找空表 select &apos;alter table &apos;||table_name||&apos; allocate extent;&apos; from user_tables where num_rows=0 把查询结果导出，执行导出的语句 &apos;ALTERTABLE&apos;||TABLE_NAME||&apos;ALLOCATEEXTENT;&apos; ----------------------------------------------------------- alter table AQ$_AQ$_MEM_MC_H allocate extent; alter table AQ$_AQ$_MEM_MC_G allocate extent; alter table AQ$_AQ$_MEM_MC_I allocate extent;3、然后再执行 exp 导出 对于还没建表时（对以前导入的空表不产生作用，仍不能导出，只能对后面新增的表产生作用）：设置deferred_segment_creation参数 show parameter deferred_segment_creation alter system set deferred_segment_creation=false; show parameter deferred_segment_creation导入方法一：（建议） sqlplus中 create or replace directory file_path as &apos;D:\oracle\data&apos;; cmd下（version防止数据库版本不同 服务器版、标准版、标准版1） impdp fjznsd/fjznsd@localhost/orcl directory=file_path dumpfile=fjzn.DAT remap_schema=FJZNSD:FJZNSD table_exists_action=replace logfile=fjzn.log version=10.2.0方法二： imp IPM/IPM@localhost/orcl file=&quot;E:\123.DMP&quot; full=y;方法三： sql导入（非常慢 并且不能导入） exp/imp和expdp/impdp的区别迁移从旧表导出到新表（表合并 + 表拆分 + 字段名不同） 1.表设计 把列名改相同 2.用navicat导出成excel（记得勾选包括列名） 3.将excel类型的时间 改为文本 =TEXT(A1,’yyyy/mm/dd’) 复制后仅粘贴数值 4.在excel中 菜单栏排序后 自己检查、去重 批量生成sql 复制后仅粘贴数值： =CONCATENATE(“insert into 表名 (“,$A$1,”,”,$B$1,”,”,$C$1,”) values (‘“,A2,”‘,’”,B2,”‘,TO_DATE(‘“,C2,”‘,’yyyy/mm/dd’));”) 5.在navicat中执行sql]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle导入导出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle11b的url]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2Foracle%2Foracle11b%E7%9A%84url%2F</url>
    <content type="text"></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle11b的url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM对象]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%A1%86%E6%9E%B6%2F%E5%89%8D%E7%AB%AF%2FJS%E5%8F%8AJQuery%2FDOM%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[获取DOM对象sdocument.getElementById(&quot;ID的值&quot;); document.getElementsByClassName(&quot;类名&quot;) document.getElementsByTagName(&quot;标签名&quot;); document.getElementsByName(&quot;name属性的值&quot;) document.querySelector(&quot;选择器&quot;);//只能获取第一个 document.querySelectorAll(&quot;选择器&quot;)//获取所有的，返回的数组 创建DOM对象var div = document.createElement(&quot;标签名&quot;);//返回的&lt;div&gt;&lt;/div&gt; var text = document.createTextNode(&quot;aa&quot;)//创建了一个&quot;aa&quot;字符串 操作DOM对象的属性第一种方式弊端：只能操作W3C提供的标签的属性 1.先获取对象 2.对象名.属性名 第二种方式获取属性值：dom对象.getAttribute(&quot;属性名&quot;) 设置属性值：dom对象.setAttribute(&quot;属性名&quot;,&quot;属性值&quot;); 删除属性值：dom对象.removeAttribute(&quot;属性名&quot;); 总结如果只操作原有属性，用哪种方式都行，但是如果要操作自定义属性，那么必须使用第二种方式 删除,添加DOM对象提示：按钮使用超链接完成 超链接当作按钮使用时候的注意事项href=&quot;&quot;默认会刷新当前页面 href=&quot;#&quot;就会滚动到页面的最上面 所以我们的目标是点击超链接的时候什么都不做 1&lt;a href=&quot;javascript:void(0)&quot; &gt;添加&lt;/a&gt; 添加: 父元素.appendChild(子元素) 删除 父元素.removeChild(子元素) 通过JS操作样式1.对象名.style.样式名=&quot;值&quot; 2.对象名.className = &quot;类名&quot;; 总结0.js组成ESMAScript(基本语法)+BOM+DOM DEBUG1.F12 2.点击console旁边的Source 3.找到JS源代码 4.添加断点 5.刷新页面(或触发事件)，目的是让JS执行 6.F10一行一行执行,F8进入下一个断点 7.选中要观察的变量，右键 xxxx watch 1.通过JS操作标签1.1获取标签对象1var dom对象 = document.getElementById("id值"); 1.2操作标签对象的普通属性1234//获取属性值console.log(dom对象.属性名);//设置属性值dom对象.属性名 = &quot;值&quot;; 1.3操作标签对象的特殊属性innerHTML1dom对象.innerHTML = &quot;html代码&quot;; 2.通过JS给标签绑定事件2.1绑定事件的第一种方式1&lt;button onclick="console.log('我被点击了');" type="button"&gt;孔老&lt;/button&gt; 通过标签的onclick属性绑定事件,属性值是一段JS代码 2.2绑定事件的第一种方式变形12345678910&lt;script&gt; //把代码抽取到方法中 function aa()&#123; for(var i=0; i&lt;100; i++)&#123; console.log(i); &#125; &#125; &lt;/script&gt;&lt;button onclick="aa()" type="button"&gt;孔老&lt;/button&gt; 因为这段代码可能非常长，比如: &lt;button onclick=&quot;for(var i=0;i&lt;100; i++){console.log(i);}&quot; type=&quot;button&quot;&gt;孔老 如果以属性的形式编写代码，特别不方便阅读，所以把代码抽取到方法中，然后调用方法就好了 孔老 2.3绑定事件的第二种方式通过DOM对象来绑定 1234567&lt;button id="btn" &gt;孔老&lt;/button&gt;&lt;script&gt; var btn = document.getElementById("btn"); btn.onclick = function()&#123;//必须点击按钮才能触发事件的执行 console.log(1); &#125;&lt;/script&gt; 2.5灯泡案例1.页面应该存放img标签，并且设定默认的图片 2.给图片标签绑定单击事件 3.在单击事件中去修改img标签的src属性来实现切换图片 ```html &lt;script&gt; var img = document.getElementById(&quot;light&quot;); var flag = false;//false关灯状态 img.onclick = function(){ if(!flag){//如果是关灯状态(flag==false)，就改为开灯,flag = true img.src = &quot;img/on.gif&quot;; flag = true; }else{//如果是开灯状态(flag==true)，就改为关灯flag = false; img.src = &quot;img/off.gif&quot;; flag = false; } } &lt;/script&gt;L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/blog/live2dw/assets/z16.model.json"},"display":{"position":"left","width":200,"height":400,"hOffset":50,"vOffset":80},"mobile":{"show":true}});]]></content>
      <categories>
        <category>JS及Jquery</category>
      </categories>
      <tags>
        <tag>DOM对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE控制台报错addEventListener]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%A1%86%E6%9E%B6%2F%E5%89%8D%E7%AB%AF%2FJS%E5%8F%8AJQuery%2FIE%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%8A%A5%E9%94%99addEventListener%2F</url>
    <content type="text"><![CDATA[IE如果控制台报错addEventListener 说明IE版本过低（9以下 如果是IE11则关闭兼容模式 根本原因是jquery1.x）兼容IE9以下的addEventListener事件绑定方法（所有调用addEventListener的方法调用自定义Event.addEvents方法）： 123456789101112131415var Event = &#123;&#125;;Event.addEvents = function(target,eventType,handle)&#123; if(document.addEventListener)&#123; Event.addEvents = function(target,eventType,handle)&#123; target.addEventListener(eventType,handle,false); &#125;; &#125;else&#123; Event.addEvents = function(target,eventType,handle)&#123; target.attachEvent(&apos;on&apos;+eventType,function()&#123; handle.call(target,arguments); &#125;); &#125;; &#125;; Event.addEvents(target,eventType,handle);&#125;;]]></content>
      <categories>
        <category>JS及Jquery</category>
      </categories>
      <tags>
        <tag>IE控制台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL索引失效]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[1.like查询以%开头（like ‘%abc’ 或者like ‘%abc%’，’abc%’不会失效）2.条件查询有 or3. 4.查询is null条件使用 &lt;&gt; 、not in 、not exist、!=]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单操作]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%A1%86%E6%9E%B6%2F%E5%89%8D%E7%AB%AF%2FJS%E5%8F%8AJQuery%2FJS%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[js去掉换行str=str.replace(/^\n+|\n+$/g,&quot;&quot;); 日期的正则表达式yyyy-MM-dd /^[1-2][0-9][0-9][0-9]-[0-1]{0,1}[0-9]-[0-3]{0,1}[0-9]$/yyyy/M/dd /^[1-2][0-9][0-9][0-9]/[0-1]{0,1}[0-9]/[0-3]{0,1}[0-9]$/ 正则必填或不为空java：\S+js：/\S+/excel导入验证规则会用到!!正则验证数据格式 !!复杂验证 验证内容 （还可能用到复杂的验证 比如导入的数据 有效期时间必须大于导入时间 还可能支持同时多种验证 先验证时间格式 后比较时间）科学计数法的数据（比较准确）^((-?\d+.\d*)[Ee]{1}(-?\d+))$ （0.e0的数据） 去掉字符串中所有的空格或单引号str=str.replace(/\s/g,&quot;&quot;);b= b.replace(/&#39;/g, &quot;&quot;); 获得年龄function getAge(str){ var r = str.match(/^(\d{1,4})(-|/)(\d{1,2})\2(\d{1,2})$/); if(r==null)return false; var d= new Date(r[1],r[3]-1,r[4]); if(d.getFullYear()==r[1]&amp;&amp;(d.getMonth()+1)==r[3]&amp;&amp;d.getDate()==r[4]){ var date = new Date(); var Y = date.getFullYear() - r[1]; var M = date.getMonth() + 1 - r[3]; var D = date.getDate(); if(parseInt(D) - parseInt(r[4]) &lt; 0){ M–; if(M&lt;0){ Y–; M = 11; } } if(M&lt;0){ Y–; M = 11; } return M?(Y+&quot;岁零&quot;+M+&quot;月&quot;):(Y+&quot;岁&quot;); } return(&quot;日期格式错误！&quot;); } 获得天数差寻找第三方接口 判断法定节假日、调休日、周末、工作日字符串 数组相互转换 数组转字符串： var a, b; a = new Array(0,1,2,3,4); b = a.join(&quot;,&quot;); 字符串转数组： var s = &quot;abc,abcd,aaa&quot;; ss = s.split(&quot;,&quot;);// 在每个逗号处进行分解 [&quot;abc&quot;, &quot;abcd&quot;, &quot;aaa&quot;] var s1 = &quot;helloworld&quot;; ss1 = s1.split(‘’); // 每个字符分解 [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;] JSON的 新增 修改 删除对象的 新增 修改 删除删除 delete 对象.属性 数组的 新增 修改 删除JS中浮点型小数计算误差]]></content>
      <categories>
        <category>JS及Jquery</category>
      </categories>
      <tags>
        <tag>简单操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax参数]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%A1%86%E6%9E%B6%2F%E5%89%8D%E7%AB%AF%2FJS%E5%8F%8AJQuery%2Fajax%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[$.ajax({ url: &quot;com.fcb.erp.tools.util.runSql.biz.ext&quot;, type: &#39;POST&#39;, data: json, cache: false, //cache属性是true时：在第一次请求完成之后，如果地址和参数不变化，第二次去请求， // 会默认获取缓存中的数据，不去读取服务器端的最新数据。 //cache属性是false时：每次读取的是最新的数据。 //ajax缓存只对GET方式的请求有效，因为浏览器认为POST请求提交的内容必定有变化，所以不走缓存。 contentType:&#39;text/json&#39;, async: true/false,//异步还是同步 默认是true success: function (data) { console.info(data); }}); 联动 居住区域 ${area.areaName} 居住楼宇 form.on(‘select(provSel)’, function (data) { $.ajax({ url: &quot;&lt;%=request.getContextPath()%&gt;/AddrServlet&quot;, dataType: &apos;json&apos;, data: { action:&quot;queryBuild&quot;, areaId: data.value }, success: function (result) { var arr = eval(result); $(&quot;#build option&quot;).remove(); $.each(arr, function(key, val) { $(&quot;#build&quot;).append(&quot;&lt;option value=&apos;&quot; + val.buildingId + &quot;&apos;&gt;&quot; + val.buildingName + &quot;&lt;/option&gt;&quot;) }); // 重新渲染，否则加载不出来 form.render(&apos;select&apos;); } });}); private void queryBuild(HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException { request.setCharacterEncoding(“utf-8”); response.setContentType(“text/html;charset=UTF-8”); String areaid = request.getParameter(&quot;areaId&quot;); String sql = &quot;select * from building where area_id = ?&quot;; List&lt;Building&gt; buildingListlist = qr.query(JdbcUtil.getConnection(), sql, new BeanListHandler&lt;&gt;(Building.class), areaid); /* JSONArray jsonArray = new JSONArray(); for(int i = 0;i &lt; buildingListlist.size();i++){ JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;building_id&quot;,buildingListlist.get(i).getBuilding_id()); jsonObject.put(&quot;building_name&quot;,buildingListlist.get(i).getBuilding_name()); jsonArray.add(jsonObject); } */ JSONArray jsonArray = JSONArray.toArray(buildingListlist); response.getWriter().print(jsonArray);}]]></content>
      <categories>
        <category>JS及Jquery</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听回车事件]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%A1%86%E6%9E%B6%2F%E5%89%8D%E7%AB%AF%2FJS%E5%8F%8AJQuery%2F%E7%9B%91%E5%90%AC%E5%9B%9E%E8%BD%A6%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[页面上监听回车调用方法可用于 直接回车登陆 以及 直接回车查询document.onkeydown = function(){ var event = window.event; if (event.keyCode == 13) { search(); }};$(document).keydown(function(event){ if(event.keyCode == 13){ alert(&#39;你按下了Enter&#39;); }});]]></content>
      <categories>
        <category>JS及Jquery</category>
      </categories>
      <tags>
        <tag>js监听</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5、SHA1、SHA256]]></title>
    <url>%2Fblog%2F2019%2F09%2F21%2F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%A1%86%E6%9E%B6%2F%E5%90%8E%E5%8F%B0%2F%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%2FMD5%E3%80%81SHA1%E3%80%81SHA256%2F</url>
    <content type="text"><![CDATA[以下是对数据加密的几种方法 MD5,sha1,sha256; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import java.io.UnsupportedEncodingException; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Scanner; import org.apache.commons.codec.binary.Hex; /** * 常見的几种加密方式 */ public class Encrypt &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String next = sc.next(); //123 String md5str = string2MD5(next); //202CB962AC59075B964B07152D234B70 String sha1str = string2Sha1(next); //40bd001563085fc35165329ea1ff5c5ecbdbbeef String sha256str = String2SHA256(next); //a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3 String sha256Javastr = String2SHA256StrJava(next); //a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3 System.out.println("next"); System.out.println("md5str:"+md5str); System.out.println("sha1str:"+sha1str); System.out.println("sha256str:"+sha256str); System.out.println("sha256Javastr："+sha256Javastr); &#125; /** * MD5加密 生成32位md5码 */ public static String string2MD5(String inStr)&#123; MessageDigest md5 = null; try&#123; md5 = MessageDigest.getInstance("MD5"); &#125;catch (Exception e)&#123; System.out.println(e.toString()); e.printStackTrace(); return ""; &#125; char[] charArray = inStr.toCharArray(); byte[] byteArray = new byte[charArray.length]; for (int i = 0; i &lt; charArray.length; i++) byteArray[i] = (byte) charArray[i]; byte[] md5Bytes = md5.digest(byteArray); StringBuffer hexValue = new StringBuffer(); for (int i = 0; i &lt; md5Bytes.length; i++)&#123; int val = ((int) md5Bytes[i]) &amp; 0xff; if (val &lt; 16) hexValue.append("0"); hexValue.append(Integer.toHexString(val)); &#125; return hexValue.toString().toUpperCase(); &#125; /** * SHA1加密 * @param str * @return */ public static String string2Sha1(String str)&#123; if(str==null||str.length()==0)&#123; return null; &#125; char hexDigits[] = &#123;'0','1','2','3','4','5','6','7','8','9', 'a','b','c','d','e','f'&#125;; try &#123; MessageDigest mdTemp = MessageDigest.getInstance("SHA1"); mdTemp.update(str.getBytes("UTF-8")); byte[] md = mdTemp.digest(); int j = md.length; char buf[] = new char[j*2]; int k = 0; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; buf[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; buf[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(buf); &#125; catch (Exception e) &#123; return null; &#125; &#125; /** * 利用Apache的工具类实现SHA-256加密 * 所需jar包下載 http://pan.baidu.com/s/1nuKxYGh * @param str 加密后的报文 * @return */ public static String String2SHA256(String str)&#123; MessageDigest messageDigest; String encdeStr = ""; try &#123; messageDigest = MessageDigest.getInstance("SHA-256"); byte[] hash = messageDigest.digest(str.getBytes("UTF-8")); encdeStr = Hex.encodeHexString(hash); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return encdeStr; &#125; //--------- /** * 利用java原生的摘要实现SHA256加密 * @param str 加密后的报文 * @return */ public static String String2SHA256StrJava(String str)&#123; MessageDigest messageDigest; String encodeStr = ""; try &#123; messageDigest = MessageDigest.getInstance("SHA-256"); messageDigest.update(str.getBytes("UTF-8")); encodeStr = byte2Hex(messageDigest.digest()); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return encodeStr; &#125; /** * 将byte转为16进制 * @param bytes * @return */ private static String byte2Hex(byte[] bytes)&#123; StringBuffer stringBuffer = new StringBuffer(); String temp = null; for (int i=0;i&lt;bytes.length;i++)&#123; temp = Integer.toHexString(bytes[i] &amp; 0xFF); if (temp.length()==1)&#123; //1得到一位的进行补0操作 stringBuffer.append("0"); &#125; stringBuffer.append(temp); &#125; return stringBuffer.toString(); &#125; &#125;]]></content>
      <categories>
        <category>常用加密</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07mysql集群和mycat]]></title>
    <url>%2Fblog%2F2019%2F09%2F20%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%2F07mysql%E9%9B%86%E7%BE%A4%E5%92%8Cmycat%2F</url>
    <content type="text"><![CDATA[mysql 集群主从复制（自带）方式有多种：基于基于日志（binlog）的主从复制方式、 原理 Master将数据改变记录到二进制日志(binary log)中，也就是配置文件log-bin指定的文件，这些记录叫做二进制日志事件(binary log events)； Slave 通过 I/O 线程读取 Master 中的 binary log events 并写入到它的中继日志(relay log)； Slave 重做中继日志中的事件， 把中继日志中的事件信息一条一条的在本地执行一次，完成数据在本地的存储， 从而实现将改变反映到它自己的数据(数据重放)。 主从配置需要注意的点 主从服务器操作系统版本和位数一致； Master 和 Slave 数据库的版本要一致； Master 和 Slave 数据库中的数据要一致； Master 开启二进制日志， Master 和 Slave 的 server_id 在局域网内必须唯一； 步骤： Master配置 安装数据库； 修改数据库配置文件， 指明 server_id， 开启二进制日志(log-bin)； vim /etc/my.cnf [mysqld] skip-name-resolvelog-bin=mysql-binlog_timestamps=SYSTEMserver-id=111 启动数据库， 查看当前是哪个日志， position 号是多少； SHOW MASTER STATUS; show variables like ‘server_id’; set global server_id=111; #此处的数值和my.cnf里设置的一样就行 登录数据库， 授权数据复制用户（IP 地址为从机 IP 地址， 如果是双向主从， 这里的还需要授权本机的 IP 址， 此时自己的 IP 地址就是从 IP 地址)； 备份数据库（记得加锁和解锁）； 传送备份数据到 Slave 上； 启动数据库； 主机查看从机 show slave hosts; Slave 上的配置 安装数据库 （如果服务器完全复制 需要删掉/var/lib/mysql/auto.cnf文件并重启mysql 重新生成mysql的uuid） 修改数据库配置文件， 指明 server_id（如果是搭建双向主从的话， 也要开启二进制日志 log-bin）； vim /etc/my.cnf [mysqld]log-bin=mysql-binlog_timestamps=SYSTEMserver-id=112 show variables like ‘server_id’;log_timestamps=SYSTEMset global server_id=112; #此处的数值和my.cnf里设置的一样就行 启动数据库， 还原备份； 查看当前是哪个日志， position 号是多少（单向主从此步不需要， 双向主从需要）； SHOW MASTER STATUS; 指定 Master 的地址、 用户、 密码等信息；（show的内容） CHANGE MASTER TOMASTER_HOST=’192.168.1.111’,MASTER_USER=’root’,MASTER_PASSWORD=’Root123.’,MASTER_LOG_FILE=’mysql-bin.000001’,MASTER_LOG_POS=155; 开启同步， 查看状态。show slave status\G;start slave;show slave status\G; 确保Slave_IO_Running=Yes Slave_SQL_Running=Yes 否则重新配置从服务器配置文件（或查看上次错误原因Last_IO_Error） 读写分离（mysql-proxy 第三方）1.配置文件 vim /etc/my.cnf 主 12345678[mysqld]log-bin=mysql-bin #从库会基于此log-bin来做复制binlog-do-db=mytest #用于读写分离的具体数据库，这里我创建了mytest作测试binlog_ignore_db=mysql #不用于读写分离的具体数据库binlog_ignore_db=information_schema #和binlog-do-db一样，可以设置多个#选择row模式 binlog-format=ROWserver-id=1 从 123456[mysqld]log-bin=mysql-bin #从库会基于此log-bin来做复制replicate-do-db=mytest #用于读写分离的具体数据库，这里我创建了mytest作测试#选择row模式 binlog-format=ROWserver-id=2 2.mysql-proxy是官方提供的mysql中间件产品可以实现负载平衡，读写分离（配多个 防止单点失效） 下载 mysql-proxy-并安装 创建配置文件 安装目录/bin/mysql-proxy.conf 123456789101112131415161718[mysql-proxy]#用于中间件连接的用户admin-username=rootadmin-password=root#根据存放的文件位置自行调整admin-lua-script=C:/mysql-proxy-0.8.5-windows-x86-32bit/lib/mysql-proxy/lua/admin.lua #主库服务器+端口proxy-backend-addresses=192.168.103.207:3307#从库服务器+端口，多个从库用，隔开proxy-read-only-backend-addresses=192.168.103.208:3307#日志文件存放位置，如果你指定了一个路径，请确保手动创建了对应的文件夹，否则会报错log-file=C:/mysql-proxy-0.8.5-windows-x86-32bit/log/mysql-proxy.log#日志级别log-level=debug#以守护进程方式运行daemon=true#长连接keepalive=true 启动 1.\mysql-proxy.exe -P 192.168.103.203:6217 --defaults-file=mysql-proxy.conf 3.下载Atlas会有两个版本，其中有个分表的版本，但是这个需要其他的依赖，我这边不需要分表这种需求，所以安装普通的版本 ​ Atlas (普通) : Atlas-2.2.1.el6.x86_64.rpm ​ Atlas (分表) : Atlas-sharding_1.0.1-el6.x86_64.rpm 下载并安装 /usr/local/mysql-proxy/里有4个文件夹（bin conf lib log） bin目录下放的都是可执行文件 \1. “encrypt”是用来生成MySQL密码加密的，在配置的时候会用到 \2. “mysql-proxy”是MySQL自己的读写分离代理 \3. “mysql-proxyd”是360弄出来的，后面有个“d”，服务的启动、重启、停止。都是用他来执行的 conf目录下放的是配置文件 \1. “test.cnf”只有一个文件，用来配置代理的，可以使用vim来编辑 进入bin目录，使用encrypt来对数据库的密码进行加密，我的MySQL数据的用户名是buck，密码是hello，我需要对密码进行加密 1./encrypt hello 配置Atlas，使用vim进行编辑 vim test.cnf 12345678910111213141516171819#管理接口的用户名admin-username = user#管理接口的密码admin-password = pwd#Atlas后端连接的MySQL主库的IP和端口，可设置多项，用逗号分隔proxy-backend-addresses = 192.168.246.134:3306#Atlas后端连接的MySQL从库的IP和端口，@后面的数字代表权重，用来作负载均衡，若省略则默认为1，可设置多项，用逗号分隔proxy-read-only-backend-addresses = 192.168.246.135:3306@1#用户名与其对应的加密过的MySQL密码，密码使用PREFIX/bin目录下的加密程序encrypt加密，下行的user1和user2为示例，将其替换为你的MySQL的用户名和加密密码！pwds = buck:RePBqJ+5gI4=#Atlas监听的工作接口IP和端口proxy-address = 0.0.0.0:1234#Atlas监听的管理接口IP和端口（还可以指定IP，其他的IP无法访问管理员的命令界面）admin-address = 0.0.0.0:2345 启动 1./mysql-proxyd test start 确定mysql本身进不去 12/etc/init.d/mysqld statusmysql Atlas的管理模式能进去 它会把自己当成一个MySQL数据库mysql -h127.0.0.1 -P2345 -uuser -ppwd 12查看功能select * from help; 通过工作接口来访问 mysql -h127.0.0.1 -P1234 -ubuck -phello 可以让数据库某一台down掉，来测试监控的可用性 select * from backends; 读写分离测试这里测试读写分离需要使用到Jmeter了，它是Java写第一套开源的压力测试工具，因为这个比较方便。他有专门测试MySQL的模块，需要使用MySQL的JDBC驱动jar包，配置很简单，东西很好很强大很好用。 Jmeter下载地址：http://jmeter.apache.org/download_jmeter.cgi MySQL的JDBC ：http://dev.mysql.com/downloads/connector/j/ mycat集群（第三方）简介支持JDBC连接ORACLE、DB2、SQL Server，将其模拟为MySQL Server使用 1、Schema：逻辑库，与MySQL中的Database（数据库）对应，一个逻辑库中定义了所包括的Table。 2、Table：表，即物理数据库中存储的某一张表，与传统数据库不同，这里的表格需要声明其所存储的逻辑数据节点DataNode。在此可以指定表的分片规则。 3、DataNode：MyCAT的逻辑数据节点，是存放table的具体物理节点，也称之为分片节点，通过DataSource来关联到后端某个具体数据库上 4、DataSource：定义某个物理库的访问地址，用于捆绑到Datanode上 数据切分介绍垂直分割（不同表在不同数据库） 优点： 拆分后业务清晰，拆分规则明确。 系统之间整合或扩展容易。 数据维护简单。 缺点： 部分业务表无法join，只能通过接口方式解决，提高了系统复杂度。 受每种业务不同的限制存在单库性能瓶颈，不易数据扩展跟性能提高。 事务处理复杂。 由于垂直切分是按照业务的分类将表分散到不同的库，所以有些业务表会过于庞大，存在单库读写与存储瓶颈，所以就需要水平 拆分来做解决。 水平分割（数据量） 几种典型的分片规则包括： 按照用户ID求模，将数据分散到不同的数据库，具有相同数据用户的数据都被分散到一个库中。 按照日期，将不同月甚至日的数据分散到不同的库中。 按照某个特定的字段求摸，或者根据特定范围段分散到不同的库中。 优点有： 拆分规则抽象好，join操作基本可以数据库做。 不存在单库大数据，高并发的性能瓶颈。 应用端改造较少。 提高了系统的稳定性跟负载能力。 缺点有： 拆分规则难以抽象。 分片事务一致性难以解决。 数据多次扩展难度跟维护量极大。 跨库join性能较差。 前面讲了垂直切分跟水平切分的不同跟优缺点，会发现每种切分方式都有缺点，但共同的特点缺点有： 引入分布式事务的问题。 跨节点Join的问题。 跨节点合并排序分页问题。 多数据源管理问题。安装 官方网站： http://www.mycat.org.cn/ github地址 https://github.com/MyCATApache 下载后解压 12cd /usr/mycattar -zxvf Mycat-server-1.6.7.3-release-20190828135747-linux.tar.gz 启动命令：./mycat start 停止命令：./mycat stop 重启命令：./mycat restart 注意：可以使用mysql的客户端直接连接mycat服务。默认服务端口为8066 1mysql -uroot -p -P8066 -h127.0.0.1 -default_auth=mysql_native_password（因为连的mysql8 不写-default_auth会报密码错误 -h必须写上并加上IP） –bin 启动目录–conf 配置文件存放配置文件–lib MyCAT自身的jar包或依赖的jar包的存放目录。–logs MyCAT日志的存放目录。日志存放在logs/log中，每天一个文件 配置由于mycat不支持mysql8.0，所以需要将mysql8.0配置成5.x 1.修改加密规则 在mysql8之前的版本使用的密码加密规则是mysql_native_password，但是在mysql8则是caching_sha2_password。 12345use mysql;select user,host,plugin from user;update user set plugin=&apos;mysql_native_password&apos; where User=&apos;root&apos;;#修改加密规则ALTER USER &apos;root&apos;@&apos;localhost&apos; BY &apos;Root123.&apos;;#更新一下用户的密码FLUSH PRIVILEGES; #刷新权限 2.如果是在Linux平台，在首次启动前设置lower_case_table_names = 1（表名大小写不敏感），需要删除数据（不知道需不需要） 123456systemctl stop mysqld.servicerm -rf /var/lib/mysqlvim /etc/my.cnflower_case_table_names=1保存systemctl restart mysqld.service https://blog.csdn.net/jaysonhu/article/details/52858535 配置schema.xml管理着MyCat的逻辑库、表、分片规则、DataNode以及DataSource 是逻辑库定义和表以及分片定义的配置文件。 数据库8.0 所以需要替换jdbc驱动包和连接方式 123456789#删除mycat/lib下的mysql5.x驱动包（不删 可能也行）cd /usr/mycat/mycat/ligrm mysql-connector-java-5.1.35.jar放入mysql8.0驱动包 mysql-connector-java-8.0.17.jar对文件赋权限chmod 777 mysql-connector-java-8.0.17.jar如果mysql unblock with ‘mysqladmin flush-hosts’解决方法登陆mysql -u root -p 后执行命令 flush hosts; vim schema.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;&lt;mycat:schema xmlns:mycat=&quot;http://org.opencloudb/&quot;&gt;&lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt;&lt;!-- auto sharding by id (long) --&gt; &lt;table name=&quot;TB_ITEM&quot; dataNode=&quot;dn1,dn2,dn3&quot; rule=&quot;auto-sharding-long&quot; /&gt; &lt;table name=&quot;TB_USER&quot; primaryKey=&quot;ID&quot; type=&quot;global&quot; dataNode=&quot;dn1,dn2&quot; /&gt; &lt;/schema&gt; &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;localhost1&quot; database=&quot;db1&quot; /&gt; &lt;dataNode name=&quot;dn2&quot; dataHost=&quot;localhost2&quot; database=&quot;db2&quot; /&gt; &lt;dataNode name=&quot;dn3&quot; dataHost=&quot;localhost1&quot; database=&quot;db3&quot; /&gt; &lt;dataHost name=&quot;localhost1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;#native#改成jdbc&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- can have multi write hosts --&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;#192.168.1.111:3306#改成jdbc:mysql://192.168.1.111:3306?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF8&amp;amp;serverTimezone=UTC&quot; user=&quot;root&quot; password=&quot;root&quot;&gt; &lt;!-- can have multi read hosts --&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; &lt;dataHost name=&quot;localhost2&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- can have multi write hosts --&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.25.166:3306&quot; user=&quot;root&quot; password=&quot;root&quot;&gt; &lt;!-- can have multi read hosts --&gt; &lt;/writeHost&gt; &lt;/dataHost&gt;&lt;/mycat:schema&gt; 配置server.xml保存了所有mycat需要的系统配置信息 是Mycat服务器参数调整和用户授权的配置文件。 1234567&lt;user name=&quot;test&quot;&gt; &lt;property name=&quot;password&quot;&gt;test&lt;/property&gt; &lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt; &lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt;&lt;/user&gt; 123456mysql -uroot -p -P8066 -h127.0.0.1 -default_auth=mysql_native_password数据系统mysql -uroot -p -P9066 -h127.0.0.1 -default_auth=mysql_native_password管理系统常用命令show @@help; 配置rule.xml是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改需要重启MyCAT。 rule.xml里面就定义了我们对表进行拆分所涉及到的规则定义，可以灵活的对表使用不同的分片算法，或者对表使用相同的算法但具体的参数不同。这个文件里面主要有tableRule和function这两个标签。在具体使用过程中可以按照需求添加tableRule和function。可以不做修改，使用默认配置 配置log4j.xml日志存放在logs/log中，每天一个文件，日志的配置是在conf/log4j.xml中，根据自己的需要可以调整输出级别为debug debug级别下，会输出更多的信息，方便排查问题。 autopartition-long.txt,partition-hash-int.txt,sequence_conf.properties， sequence_db_conf.properties 分片相关的id分片规则配置文件 测试分片创建表并插入数据 由于配置的分片规则为“auto-sharding-long”，所以mycat会根据此规则自动分片。 每个datanode中保存一定数量的数据。根据id进行分片 经测试id范围为： Datanode1：1~5000000 Datanode2：5000000~10000000 Datanode3：10000001~15000000 当15000000以上的id插入时报错： [Err] 1064 - can’t find any valid datanode :TB_ITEM -&gt; ID -&gt; 15000001 此时需要添加节点了。 主从复制（同上） 读写分离 Mycat 1.4 支持MySQL主从复制状态绑定的读写分离机制，让读更加安全可靠，配置如下： 123456789101112&lt;dataNode name=&quot;dn1&quot; dataHost=&quot;localhost1&quot; database=&quot;db1&quot; /&gt; &lt;dataNode name=&quot;dn2&quot; dataHost=&quot;localhost1&quot; database=&quot;db2&quot; /&gt; &lt;dataNode name=&quot;dn3&quot; dataHost=&quot;localhost1&quot; database=&quot;db3&quot; /&gt; &lt;dataHost name=&quot;localhost1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;2&quot; slaveThreshold=&quot;100&quot;&gt; &lt;heartbeat&gt;show slave status&lt;/heartbeat&gt; &lt;writeHost host=&quot;hostM&quot; url=&quot;192.168.25.134:3306&quot; user=&quot;root&quot; password=&quot;root&quot;&gt; &lt;readHost host=&quot;hostS&quot; url=&quot;192.168.25.166:3306&quot; user=&quot;root&quot; password=&quot;root&quot; /&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; (1) 设置 balance=”1”与writeType=”0” Balance参数设置： \1. balance=“0”, 所有读操作都发送到当前可用的writeHost上。 \2. balance=“1”，所有读操作都随机的发送到readHost。 \3. balance=“2”，所有读操作都随机的在writeHost、readhost上分发 WriteType参数设置： \1. writeType=“0”, 所有写操作都发送到可用的writeHost上。 \2. writeType=“1”，所有写操作都随机的发送到readHost。 \3. writeType=“2”，所有写操作都随机的在writeHost、readhost分上发。 “readHost是从属于writeHost的，即意味着它从那个writeHost获取同步数据，因此，当它所属的writeHost宕机了，则它也不会再参与到读写分离中来，即“不工作了”，这是因为此时，它的数据已经“不可靠”了。基于这个考虑，目前mycat 1.3和1.4版本中，若想支持MySQL一主一从的标准配置，并且在主节点宕机的情况下，从节点还能读取数据，则需要在Mycat里配置为两个writeHost并设置banlance=1。” (2) 设置 switchType=”2” 与slaveThreshold=”100” switchType 目前有三种选择： -1**：表示不自动切换** 1 ：默认值，自动切换 2 ：基于MySQL主从同步的状态决定是否切换 “Mycat心跳检查语句配置为 show slave status ，dataHost 上定义两个新属性： switchType=”2” 与slaveThreshold=”100”，此时意味着开启MySQL主从复制状态绑定的读写分离与切换机制。Mycat心跳机制通过检测 show slave status 中的 “Seconds_Behind_Master”, “Slave_IO_Running”, “Slave_SQL_Running” 三个字段来确定当前主从同步的状态以及Seconds_Behind_Master主从复制时延。“ 监控平台emmm… 需要用到zookeeper 目前被监控的MySQL版本支持5.7（推荐），5.6。 而且还不支持8.0。。。有点尴尬 MyCAT自增字段和返回生成的主键ID的经验分享MyCAT自增字段和返回生成的主键ID的经验分享说明：1、mysql本身对非自增长主键，使用last_insert_id()是不会返回结果的，只会返回0.2、mysql只会对定义自增长主键，可以用last_insert_id()返回主键值。 mycat目前提供了自增长主键功能，但是如果对应的mysql节点上数据表，没有定义auto_increment，那么在mycat层调用last_insert_id()也是不会返回结果的。正确使用方式如下：1、mysql定义自增主键CREATE TABLE tt2 ( id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, nm INT(10) UNSIGNED NOT NULL, PRIMARY KEY (id)) ENGINE=MYISAM AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;2、mycat定义自增[root@test conf]# vim schema.xml&lt;mycat:schema xmlns:mycat=”http://org.opencloudb/&quot;&gt; &lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt; &lt;!-- random sharding using mod sharind rule --&gt; &lt;!-- autoIncrement=&quot;true&quot; 属性--&gt; &lt;table name=&quot;tt2&quot; primaryKey=&quot;id&quot; autoIncrement=&quot;true&quot; dataNode=&quot;dn1,dn2,dn3,dn4,dn5&quot; rule=&quot;mod-long&quot; /&gt; &lt;table name=&quot;mycat_sequence&quot; primaryKey=&quot;name&quot; dataNode=&quot;dn1&quot;/&gt; &lt;/schema&gt; &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;localhost1&quot; database=&quot;db1&quot; /&gt; &lt;dataNode name=&quot;dn2&quot; dataHost=&quot;localhost1&quot; database=&quot;db2&quot; /&gt; &lt;dataNode name=&quot;dn3&quot; dataHost=&quot;localhost1&quot; database=&quot;db3&quot; /&gt; &lt;dataNode name=&quot;dn4&quot; dataHost=&quot;localhost1&quot; database=&quot;db4&quot; /&gt; &lt;dataNode name=&quot;dn5&quot; dataHost=&quot;localhost1&quot; database=&quot;db5&quot; /&gt; &lt;dataHost name=&quot;localhost1&quot; maxCon=&quot;1000&quot; minCon=&quot;20&quot; balance=&quot;0&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;127.0.0.1:3366&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; 3、mycat对应sequence_db_conf.properties增加相应设置；4、mycat的对应mycat_sequence增加对应记录。5、链接mycat，测试结果如下： 127.0.0.1/root:[TESTDB&gt; insert into tt2(nm) values (99);Query OK, 1 row affected (0.14 sec) 127.0.0.1/root:[TESTDB&gt; select last_insert_id();+——————+| LAST_INSERT_ID() |+——————+| 101 |+——————+1 row in set (0.01 sec) 127.0.0.1/root:[TESTDB&gt; insert into tt2(nm) values (99);Query OK, 1 row affected (0.00 sec) 127.0.0.1/root:[TESTDB&gt; select last_insert_id();+——————+| LAST_INSERT_ID() |+——————+| 102 |+——————+1 row in set (0.00 sec) 127.0.0.1/root:[TESTDB&gt; insert into tt2(nm) values (99);Query OK, 1 row affected (0.00 sec) 127.0.0.1/root:[TESTDB&gt; select last_insert_id();+——————+| LAST_INSERT_ID() |+——————+| 103 |+——————+1 row in set (0.00 sec) 127.0.0.1/root:[TESTDB&gt; insert into tt2(nm) values (99);Query OK, 1 row affected (0.01 sec) 127.0.0.1/root:[TESTDB&gt; select last_insert_id();+——————+| LAST_INSERT_ID() |+——————+| 104 |+——————+1 row in set (0.00 sec) 127.0.0.1/root:[TESTDB&gt; insert into tt2(nm) values (99);Query OK, 1 row affected (0.00 sec) 127.0.0.1/root:[TESTDB&gt; select last_insert_id();+——————+| LAST_INSERT_ID() |+——————+| 105 |+——————+1 row in set (0.00 sec) 127.0.0.1/root:[TESTDB&gt; insert into tt2(nm) values (99);Query OK, 1 row affected (0.00 sec) 127.0.0.1/root:[TESTDB&gt; select last_insert_id();+——————+| LAST_INSERT_ID() |+——————+| 106 |+——————+1 row in set (0.00 sec)]]></content>
      <categories>
        <category>搭建Linux服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
        <tag>mysql集群</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fblog%2F2019%2F09%2F20%2F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%A1%86%E6%9E%B6%2F%E5%90%8E%E5%8F%B0%2FSSM%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%2FMyBatis%2F%26%2335%3B%E5%92%8C%26%2336%2F</url>
    <content type="text"><![CDATA[#{}:表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。#{}可以接收简单类型值或pojo属性值。如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。 ‘%#{name}%’ ${}:表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。 #{} 和 ${} 在预编译中的处理是不一样的#{} 在预处理时，会把参数部分用一个占位符 ? 代替${} 则只是简单的字符串替换，在动态解析阶段， sql 语句才会被解析 优先使用 #{}传表名时只能使用 ${}]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05redis环境]]></title>
    <url>%2Fblog%2F2019%2F09%2F20%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E6%90%AD%E5%BB%BALinux%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%AE%9E%E9%99%85%EF%BC%89%2F05redis%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装redis由C语言开发，安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境。 1.安装gcc 123yum list installed | grep gccyum list | grep gccyum install gcc 2.解压redis压缩包 12cd /usr/soft/tar -zxvf redis-5.0.4.tar.gz 3.编译 12345cd redis-5.0.4make编译结束Hint: It&apos;s a good idea to run &apos;make test&apos; ;) 4.安装 1make install PREFIX=/usr/soft/redis 安装结束后，/usr/soft/redis/bin下有几个可执行文件 redis-benchmark——性能测试工具redis-check-aof——AOF文件修复工具redis-check-rdb——RDB文件检查工具（快照持久化工具）redis-cli——命令行客户端redis-sentinel（链接文件 到server）redis-server——redis服务器启动命令 5.配置文件 cp /usr/soft/redis/redis-5.0.4/redis.conf /usr/soft/redis/bin/redis.conf vim /usr/soft/redis/bin/redis.conf 123456#IP绑定 69行bind 192.168.1.111#是否开启保护模式，由yes该为no 88行protected-mode no#数据库的数量(默认是16个 相互隔离 但是可以使用flushall一次清空所有的库) 根据需求修改 186行databases 16 6.启动 前端模式启动（测试） 123/usr/redis/bin/redis-serverctrl+c结束 后端模式启动 12345678vim /usr/redis/bin/redis.conf#后端模式 136行daemonize yes保存./redis-server redis.conf./redis-cli shutdown——关闭./redis-cli -h 192.168.1.111 -p 6379 shutdown 持久化Redis是一个内存数据库，为了保证数据的持久性，它提供了两种持久化方案: RDB方式（默认 通过快照完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘） AOF方式 （每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件） RDB方式Redis会在指定的情况下触发快照1. 符合自定义配置的快照规则 2. 执行save或者bgsave命令 3. 执行flushall命令 4. 执行主从复制操作 在redis.conf中设置自定义快照规则save save 900 1：表示15分钟（900秒钟）内至少1个键被更改则进行快照 可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系 配置dir指定rdb快照文件的位置dir ./ 配置dbfilename指定rdb快照文件的名称dbfilename dump.rdb 优缺点缺点：一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据 优点：RDB可以最大化Redis的性能，保存时会分出子进程，但数据量大会耗时变缺点 AOF方式开启：redis.conf配置文件中的appendonly参数开启 appendonly yes 保存位置 dir ./ 默认的文件名 appendfilename appendonly.aof 主从复制和切换主从机主redis不需要配置 只需要修改从redis配置 修改从服务器上的redis.conf文件 1slaveof 主服务器IP 主服务器端口 只有从机第一次连接上主机是全量同步断线重连有可能触发全量同步也有可能是增量同步（master判断runid是否一致）除此之外的情况都是增量同步 Sentinel 哨兵进程监控redis集群中Master主服务器工作的状态 作用：监控 提醒 自动迁移（自动改变主从机的配置文件 以及 哨兵监控文件） 修改从机的sentinel.conf 12#sentinel monitor &lt;master-name&gt; &lt;master ip&gt; &lt;master port&gt; &lt;quorum&gt;sentinel monitor mymaster 192.168.10.133 6379 1 配置文件说明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 哨兵sentinel实例运行的端口 默认26379port 26379# 哨兵sentinel的工作目录dir /tmp# 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;sentinel monitor mymaster 127.0.0.1 6379 2# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;sentinel parallel-syncs mymaster 1# 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。#3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了# 默认三分钟# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;sentinel failover-timeout mymaster 180000 #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。#对于脚本的运行结果有以下规则：#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。#通知脚本# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。# 以下参数将会在调用脚本时传给脚本:# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;# 目前&lt;state&gt;总是“failover”,# &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; sentinel client-reconfig-script mymaster /var/redis/reconfig.sh 启动 1./redis-sentinel sentinel.conf 集群]]></content>
      <categories>
        <category>搭建Linux服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
        <tag>redis安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04mysql环境]]></title>
    <url>%2Fblog%2F2019%2F09%2F20%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E6%90%AD%E5%BB%BALinux%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%AE%9E%E9%99%85%EF%BC%89%2F04mysql%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1.安装yum安装 1yum install mysql-server 官网源安装 1234567wget -ox /usr/mysql/mysql80-community-release-el7-3.noarch.rpm https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpmyum localinstall mysql80-community-release-el7-3.noarch.rpm查询可以安装的版本yum repolist all | grep mysql安装服务器版yum install mysql-community-server 压缩版安装（比较麻烦 不建议） 123456789101112131415161718tar –xzvf mysql-5.1.56.tar.gz #对mysql tar包解压缩cd myql-5.1.56./configure –prefix=/usr/local/mysql #制定mysql的安装目录make #编译源代码make install #安装cp support-files/my-medium.cnf /etc/my.cnf #复制配置文件模板cd /usr/local/mysqlbin/mysql_install_db –user=root #初始化安装mysql数据库bin/mysqld_safe –user=root &amp; #使用用户mysql安全启动mysql程序并放到后台执行配置环境变量将以下信息添加到用户下的.base_profile 文件中 #mysql items beginexport MYSQL_HOME=MySQL 安装目录export PATH=$MYSQL_HOME/bin:$PATHexport LD_LIBRARY_PATH=$MYSQL_HOME/lib:$LD_LIBRARY_PATHexport LIBPATH=$LD_LIBRARY_PATH:$LIBPATH#mysql items end 2.启动mysql12service mysqld startsystemctl start mysqld 3.修改mysqld执行权限（可能用不到）1chmod 755 /etc/rc.d/init.d/mysqld 4.修改mysql的root账户密码12345678910111213141516查看临时密码grep &apos;temporary password&apos; /var/log/mysqld.log//进入mysqlmysql -u root -p//修改密码ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;Root123.&apos;;//查看 mysql 初始的密码策略SHOW VARIABLES LIKE &apos;validate_password%&apos;;//设置密码的验证强度等级set global validate_password_policy=LOW;//设置密码的长度set global validate_password_length=6;或mysqladmin -u root password &apos;newpwd&apos;（8位+大小写+加数字+特殊字符） 5.设置mysql开机启动12chkconfig mysqld on systemctl enable mysqld.service 6.设置远程连接让%（所有ip的）用户拥有访问所有库和表的权限。用户名为root 密码为123456 1234mysql -u root -puse mysql;select host, user, authentication_string, plugin from user;update user set host = &quot;%&quot; where user = &quot;root&quot;; 1grant all privileges on *.* to root@&apos;%&apos; identified by &apos;root&apos; with grant option;(8版本用不到了) 刷新权限，不用重启立即生效 1flush privileges; 7.连接mysql时报caching_sha2_password错误原因： mysql8.0和5.x其中一个改动就是加密认证方式发生改变， caching_sha2_password是8.0mysql_native_password是5.x 解决方案： 1，更改mysql的加密认证方式 123use mysql;update user set plugin=&apos;mysql_native_password&apos; where user=&apos;root&apos;;flush privileges; 2，更改mysql的jdbc版本 8. Host is blocked because of many connection errors; unblock with ‘mysqladmin flush-hosts’报错原因： 同一个ip在短时间内产生太多（超过mysql数据库max_connection_errors的最大值）中断的数据库连接而导致的阻塞； 解决方法： 解决方法： 1、提高允许的max_connection_errors数量： ① 进入Mysql数据库查看max_connection_errors： show variables like ‘%max_connect_errors%’; ② 修改max_connection_errors的数量为1000： set global max_connect_errors = 1000; ③ 查看是否修改成功：show variables like ‘%max_connect_errors%’; 2、使用mysqladmin flush-hosts 命令清理一下hosts文件（不知道mysqladmin在哪个目录下可以使用命令查找：whereis mysqladmin）； ① 在查找到的目录下使用命令修改：mysqladmin –socket=/tmp/kkimdb.sock –port=3306 -uhyman -p flush-hosts 备注： 配置有master/slave主从数据库的要把主库和从库都修改一遍的（我就吃了这个亏明明很容易的几条命令结果折腾了大半天）； flush hosts; 也可以]]></content>
      <categories>
        <category>搭建Linux服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
        <tag>mysql安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03tomcat环境]]></title>
    <url>%2Fblog%2F2019%2F09%2F20%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E6%90%AD%E5%BB%BALinux%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%AE%9E%E9%99%85%EF%BC%89%2F03tomcat%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1.解压安装包1tar -zxvf /usr/tomcat/apache-tomcat-9.0.24.tar.gz 2.测试启动Tomcat进入tomcat的bin目录 1sh ./startup.sh 如果报错-bash: startup.sh: command not found 则chmod u+x *.sh]]></content>
      <categories>
        <category>搭建Linux服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
        <tag>tomcat安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02java环境]]></title>
    <url>%2Fblog%2F2019%2F09%2F20%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E6%90%AD%E5%BB%BALinux%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%AE%9E%E9%99%85%EF%BC%89%2F02java%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[0.删除系统预装jdk可以一条命令直接删除 1rpm -e --nodeps `rpm -qa | grep java` 1.解压tar包1tar -zxvf jdk-8u211-linux-x64.tar.gz 2.编辑java环境变量配置文件1vim /etc/profile 123456最底下加上export JAVA_HOME=/usr/soft/java/jdk1.8.0_221export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_LIB/tools.jar:$JAVA_LIB/dt.jarexport PATH=$JAVA_HOME/bin:$PATH保存退出 123source /etc/profile 使配置生效（可能会需要等一会儿才能生效）或. /etc/profile 如果报错 -bash: /user/java/jdk1.8.0_221/bin/java: Permission denied则 chmod 777 /user/java/jdk1.8.0_221/bin/java 3.查询java版本1java –version 4.运行jarjava -jar springboot-0.0.1-SNAPSHOT.jar 5.后台运行jarnohup java -jar springboot-0.0.1-SNAPSHOT.jar &amp;nohup java -jar springboot-0.0.1-SNAPSHOT.jar &gt; log.file 2&gt;&amp;1 &amp; 如果是访问云服务器的页面，可能需要配置安全规则 添加所有访问到本服务器的8080端口]]></content>
      <categories>
        <category>搭建Linux服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
        <tag>Java安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01CentOS7操作系统的基础]]></title>
    <url>%2Fblog%2F2019%2F09%2F20%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2Flinux%2F01CentOS7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[系统目录简介/ 根目录 bin (binaries)存放二进制可执行文件 sbin (super user binaries)存放二进制可执行文件，只有root才能访问 etc (etcetera)存放系统置文件 usr (unix shared resources)用于存放共享的系统资源home存放用户文件的根目录 root 超级用户目录 dev (devices)用于存放设备文件 lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt (mount)系统管理员安装临时文件系统的安装点 boot 存放用于系统引|导时使用的各种文件 tmp (tempor any)用于存放各种临时文件 var (variable)用于存放运行时需要改变数据的文件磁盘管理1.查看当前文件目录pwd 显示工作目录2.列出目录内容ls [参数][文件或目录] 缺省为ls -a ls -l 显示文件详细信息（简化命令为ll） ls -al 显示文件详细信息（包括隐藏文件） ls -a/all 显示文件名字（包括隐藏文件） ls -t 更改时间排序 ls -r 反向排序3.切换目录cd [目录] 缺省为cd ~ cd 目录名 进入指定文件夹（不存在则提示） cd ~ 当前用户目录 cd / 根目录 cd - 上次访问目录 cd .. 上一级目录4.创建目录mkdir [参数] 目录名（支持多级） mkdir -p 目录名 父目录不存在先生成父目录（parents） mkdir -v 目录名 显示执行过程5.删除目录rmdir 目录名 删除空目录文件管理文件浏览1.查看文件内容cat 文件 显示文件所有内容2.分页查看文件内容more 文件 分页显示文件内容进入后 回车 向下一行 空格 向下滚动一屏（ctrl+f） b 返回上一屏（ctrl+b） q 退出 3.分页查看文件内容增强版less [参数] 文件 less -m 文件名 百分比显示（相当于more） less -n 文件名 显示每行行数进入后 空格 前进一页（page down键） b 返回上一屏（page up键） d 前进半页 u 后退半页 回车 前进一行（方向键向下） y 后退一行（方向键向上） /字符串 向上搜索 ?字符串 向下搜索 v 进入vim编辑器 左右方向键 水平滚动条 q 退出 3.查看文件末尾（可用于查看log文件）tail 必要参数 [选择参数][文件] -行数 显示函数 -f 循环读取（ctrl+c取消） &amp; 后台运行文件操作1.复制文件或目录cp [参数] 源文件或目录 目标文件或目录 -r/--recursive 递归处理 指定目录的文件和子目录全部处理（复制目录必须带-r参数） -b 覆盖文件时备份旧文件2.移动或更名 文件或目录12mv [源文件或目录] [目标文件或目录]-f/--force 若目标文件或目录与现有文件或目录重复，则直接覆盖 3.删除 文件或目录123rm [-dfirv] [--help] [--version] [文件或目录]-f/--force 强制删除文件或目录-r/--recursive 递归处理 4.查找 文件或目录12find [目录] [参数]-name 指定字符串作为寻找文件或目录的范本文件 文档编辑1.基本操作vi或vim命令 12345vim 文件名 进入一般模式i/a/o 进入插入模式esc 从插入模式退到一般模式: 从一般模式进入命令行/末行模式:w/:wq/:q/:q! 末行模式命令：保存/保存并退出/退出/强制退出（还可以编辑环境 入寻找字符串 列出行号等） 2.常用命令插入 12 复制或粘贴 12 定位 12 删除 12 选择 12 3.管道命令| 位于回车键上面（shift+\） 1命令1|命令2 将命令1的输出内容作为命令2的输入内容 一般与grep使用 4.文本查找命令1234全局正则表达式输出grep [option] parrern [file] 搜索/过滤特定字符-i/--ignore-case 忽略大小写搭配管道命令使用 如：cat /root/install.log | grep -i control 在cat命令输出结果 过滤control 系统命令查看端口情况 netstat -anp 1.查看进程123ps [参数]-e/-a 显示所有程序-f 显示UID、PPIP、C与STIME 2.杀死进程123kill [参数] [程序] 删除执行中的程序或工资-l&lt;信息编号&gt; 列出全部的信息名称-9 pid号 强制终止 3.查看网络配置1ifconfig 4.测试网络12ping IP地址或域名ctrl+c退出ping 二进制软件包管理及配置（针对红帽系列）1.RPM包管理 RPM软件包的一个例子: sudo-1.7.2pl-5.el5.i386.rpm 其中包括软件名(sudo),版本号(1.7.2pl),发行号(5.el5),和硬件版本(i386)2.YUM包管理 应用yum的好处: 自动解决软件包依赖关系; 方便的软件包升级;wget 1.相关命令1.rpm包管理 12345678910111213141516171819rpm [参数] [软件]-a 查询所有套件-v 显示指令执行过程-h/--hash 套件安装时列出标记-q 询问模式-i/--install 套件名 安装指定套件-u/--upgrade 套件名 升级指定套件-e/--erase 套件名 删除指定套件--nodeps 不验证套件档的相互关联性挂载光盘:(?) mkdir /mnt/cdrom mount /dev/cdrom /mnt/cdrom常用：rpm -ivh 软件.rpm --安装rpm -Uvh 软件 --更新rpm -e --nodeps 软件 --强制删除rpm -qa --查看 2.yum包管理 123456yum list 软件包名 --软件包查询yum info 软件包名 --软件包信息yum install 软件 --安装yum remove 软件 --卸载yum check-update 软件 --检测升级yum update 软件包名 --升级 2.配置yum源1.备份配置文件 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2.下载阿里云的Centos-7.repo文件 1wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.rep 123456789101112131415[serverid]#serverid是用于区别各个不同的repository（仓库;贮藏室），必须有一个独一无二的名称name=Some name for this server#name，是对repository的描述#$releasever 表示当前系统的发行版本，可以通过rpm -qi centos-release命令查看#$basearch 系统硬件架构(CPU指令集),使用命令arch得到baseurl=url://path/to/repository/#可以跟多个url 但baseurl只能有一个#url之后可以加上多个选项，如gpgcheck、exclude、failovermethod等gpgcheck=1#其中gpgcheck，exclude的含义和[main]部分相同，但只对此服务器起作用(main在/etc/yum.conf中)failovermethode=priority#failovermethode 有两个选项roundrobin和priority，意思分别是有多个url可供选择时，yum选择的次序，roundrobin是随机选择，如果连接失 败则使用下一个，依次循环，priority则根据url的次序从第一个开始。如果不指明，默认是roundrobin。 阿里巴巴 网易163 清华大学 123yum list #显示yum包yum clean all #清除yum缓存yum makecache #缓存本地yum仓库中的软件包信息 3.其他方式安装源代码包安装 123456789tar –xzvf 压缩包.tar.gz (解压解包)cd 解压后目录./configure –prefix=/usr/local/指定的安装路径 (配置)说明:--prefix参数用来指定安装目录,默认是安装在/usr/local/下 rpm包是在打包的时候作者已经做好了安装的路径,所以不用设置make (编译)说明:把文件生成可用执行和使用的文件make install (安装)说明:如果在安装过程中出现了错误,那么就把安装目录和解压缩后的文件夹删除就可用了.但是如果安装的是MYSQL这样的包,就需要把MYSQL的进程停掉,然后删除安装目录和解压缩后的文件夹就可以了 shell脚本安装 1234tar –xzvf 压缩包.tar.gzcd 解压后目录cat README./setup.sh 压缩和解压12345678tar 命令 压缩或解压-c 压缩（create 建立压缩文件的参数指令）-x 解压（extract 解开压缩文件的参数指令）-z 是否使用gzip压缩-v 是否显示压缩过程文件-f 文件名 使用档名常用压缩指令：tar zcvf 文件名常用解压指令：tar zxvf 文件名 关机和重启init 3 图形界面切换命令界面 init 5 命令界面切换图形界面 init 6 或 reboot系统重启 shutdown 关机 -h now（init0） halt文件权限12345678910111213141516171819202122232425262728293031323334chmod 变更文件或目录的权限chmod [参数] [&lt;权限范围&gt;&lt;符号&gt;&lt;权限代号&gt;] 文件或目录-r/--recursive 递归处理权限范围:u:user，拥有者g:group，所属群组o:other，其他用户a:all，全部的用户符号+添加权限-取消权限权限代号r:读取，数字代号&quot;4&quot;w:写入，数字代号&quot;2&quot;x:执行文件或进入目录，数字代号&quot;1&quot;-:不具任何权限，数字代号&quot;0&quot;eg:chmod u-rwx 文件或目录（拥有者所有权限）chmod o-r-- 文件或目录（其他用户只读）chmod 777 文件或目录（全部用户所有权限）chmod 755 文件或目录（拥有者所有权限 所属群组不可写入 其他用户不可写入）linux文件权限格式&lt;类型&gt;&lt;用户&gt;&lt;组&gt;&lt;其他用户&gt;-rwxrw-r---/rwx/rw-/r--1:文件类型 d目录 -普通文件 l链接文件2-4:拥有者权限5-7:所属组权限8-10:其他用户权限 网络配置1.VIM命令配置输入ip查询命名 ip addr 也可以输入 ifconfig（如果没有ifconfig命令 则需要安装net-tools）查看ip，但此命令会出现3个条目，centos的ip地址是ens33条目中的inet值 123456789101112131415161718vim /etc/sysconfig/network-scripts/ifcfg-ens33DEVICE=eth33 #网卡名称TYPE=Ethernet #网卡类型NM_CONTROLLED=yes #BOOTPROTO=dhcp #dhcp获得id 还有设为静态static 则需要设置以下#IPADDR=192.168.1.111 #静态ip地址#GATEWAY=192.168.1.2 #网关#PREFIX=24 #子网掩码#DNS1=192.168.1.2DEFROUTE=yes #IPV4_FAILURE_FATAL=yes #IPV6INIT=no #NAME=eth33 #PEERDNS=yes #PEERROUTES=yes #LAST_CONNECT=1528693814 #ONBOOT=yes #是否开始启动网卡 重启网卡服务 12service network restart（CentOS7 网络服务器版 配置静态可能需要重启电脑 不好说） 测试确认ping www.baidu.com 确认网络恢复正常 2.setup命令配置（CentOS7之前）1234567setup防火墙配置键盘配置网络配置——设备配置——第一块网卡——设置IP地址等信息系统服务（设置开机自启动服务）验证配置上下键选择 tab键切换焦点 回车确定 3.nmtui命令配置（CentOS7之后 用了这个不能设置静态IP 关了吧）修改主机名12vim /etc/sysconfig/network（重启生效）hostnamectl set-hostname 主机名（立即生效） 用户切换su - su - root 切换root用户 su 普通用户名 exit 退出到原先的用户查看当前用户当前登录系统的用户信息 whoami 或 who am iCentOS7查看和关闭防火墙iptables通过控制端口来控制服务，而firewall则是通过控制协议来控制端口 （只能开一个） ConterOS7.0以上默认使用的是firewall，ConterOS7.0以下默认使用的是iptables firewall（很麻烦）查看防火墙状态 123firewall-cmd --state（notrunning 未启动 / running 启动）或systemctl status firewalld（更详细） 停止firewall 1systemctl stop firewalld.service 禁止firewall开机启动 1systemctl disable firewalld.service 重启防火墙 1firewall-cmd --reload 开放端口（修改后需要重启防火墙方可生效） 1firewall-cmd --zone=public --add-port=8080/tcp --permanent 查看开放的端口 1firewall-cmd --list-ports 关闭端口 1firewall-cmd --zone=public --remove-port=8080/tcp --permanent 1234567891011121314151617181920212223242526272829303132firewall-cmd --state 查看状态（若关闭，则先开启systemctl start firewalld）firewall-cmd --list-ports 查看已开放的端口开启8000端口：firewall-cmd --zone=public(作用域) --add-port=8000/tcp(端口和访问类型) --permanent(永久生效)firewall-cmd --zone=public --add-port=1521/tcp --permanentfirewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --zone=public --add-port=50070/tcp --permanentfirewall-cmd --zone=public --add-port=8088/tcp --permanentfirewall-cmd --zone=public --add-port=19888/tcp --permanentfirewall-cmd --zone=public --add-port=9000/tcp --permanentfirewall-cmd --zone=public --add-port=9001/tcp --permanentfirewall-cmd --reload -重启防火墙firewall-cmd --list-ports 查看已开放的端口systemctl stop firewalld.service停止防火墙systemctl disable firewalld.service禁止防火墙开机启动关闭端口：firewall-cmd --zone= public --remove-port=8000/tcp --permanent iptables（比较简单）安装防火墙 1yum install iptables-services 开启防火墙 1systemctl start iptables.service 关闭防火墙 1systemctl stop iptables.service 查看防火墙状态 1systemctl status iptables.service 设置开机启动 1systemctl enable iptables.service 编辑防火墙文件 12345678910111213141516171819202122232425vim /etc/sysconfig/iptables:INPUT ACCEPT [0:0]:FORWARD ACCEPT[0:0]:OUTPUT ACCEPT[0:0]-A INPUT -m state--state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -jACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 6379 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8081 -j ACCEPT-A INPUT -j REJECT--reject-with icmp-host-prohibited-A FORWARD -jREJECT --reject-with icmp-host-prohibitedCOMMIT22 ssh(默认开启)80 nginx3306 mysql6379 redis8080 tomcat8081 第二个tomcat保存 如果没有该文件 12345控制台使用iptables命令随便写一条防火墙规则iptables -A OUTPUT -j ACCEPTiptables -I INPUT -p tcp --dport 8080 -j ACCEPT或者service iptables save 重启防火墙使配置文件生效 1systemctl restart iptables.service 关闭selinux进入到/etc/selinux/config文件 12vim /etc/selinux/config将SELINUX=enforcing改为SELINUX=disabled 修改hosts文件vim /etc/hosts 配制免密登录的命令（HDFS集群用到）123456789ssh-keygen -t rsa 或 ssh-keygen（客户机上）三次回车此时/root/.ssh目录下id_rsa为私钥（客户机）id_rsa.pub为公钥（服务器）ssh-copy-id 192.168.1.111（ssh-copy-id root@主机名）输入密码 帮助文档man 命令名 更完整 help 命令名 简单叙述]]></content>
      <categories>
        <category>搭建Linux服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00Linux安装的基础]]></title>
    <url>%2Fblog%2F2019%2F09%2F20%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2Flinux%2F00Linux%E5%AE%89%E8%A3%85%E7%9A%84%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[0.检验文件完整性CentOS-7-x86_64-DVD-1810.iso sha256 文件 3213b2c34cecbb3bb817030c7f025396b658634c0cf9c4435fc0b52ec9644667 CentOS-7-x86_64-LiveGNOME-1810.iso 38d5d51d9d100fd73df031ffd6bd8b1297ce24660dc8c13a3b8b4534a4bd291c CentOS-7-x86_64-Minimal-1810.iso 6d44331cc4f6c506c7bbe9feb8468fad6c51a88ca1393ca6b8b486ea04bec3c1 CentOS-7-x86_64-DVD-1810.iso 87623c8ab590ad0866c5f5d86a2d7ed631c61d69f38acc42ce2c8ddec65ecea2 CentOS-7-x86_64-LiveKDE-1810.iso 918975cdf947e858c9a0c77d6b90a9a56d9977f3a4496a56437f46f46200cf71 CentOS-7-x86_64-Everything-1810.iso 19d94274ef856c4dfcacb2e7cfe4be73e442a71dd65cc3fb6e46db826040b56e CentOS-7-x86_64-NetInstall-1810.iso windows的cmd命令： 1234certutil -hashfile .\CentOS-7-x86_64-DVD-1810.iso SHA256SHA256 的 .\CentOS-7-x86_64-DVD-1810.iso 哈希:6d44331cc4f6c506c7bbe9feb8468fad6c51a88ca1393ca6b8b486ea04bec3c1CertUtil: -hashfile 命令成功完成。 文本比对：https://tool.lu/diff/ 1.选择语言中文——简体中文(中国) 2.安装信息摘要网络和主机名——打开以太网、修改主机名 时间和日期——亚洲、上海、修改为当前系统时间并打开网络时间（一般减八个小时） 安装源——自动检测的安装介质 软件选择——基础网页服务器——直接点完成 （开发学习选择开发及生成工作站，网页服务器选择基础网页服务器，普通用选择gnome界面版本即可，专家水平选择最小安装 特别干净 常用软件都没有） 安装位置——本地标准磁盘 3.配置root超级用户密码4.等待安装完成]]></content>
      <categories>
        <category>搭建Linux服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>
